using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace EasyAppDev.Blazor.Icons.SourceGenerator
{
    /// <summary>
    /// Source generator that creates individual ComponentBase classes for each icon.
    /// Generates fully embedded components with inline SVG content for maximum trimmability.
    /// </summary>
    [Generator]
    public class IconSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Find all icon data files (IconData/**/*.cs)
            var iconDataFiles = context.AdditionalTextsProvider
                .Where(file => file.Path.Contains("IconData") && file.Path.EndsWith(".cs"));

            // Parse all available icons from IconData
            var allIcons = iconDataFiles
                .Select((file, ct) => ParseIconFile(file, ct))
                .Where(data => data != null)
                .SelectMany((data, _) => data!)
                .Collect();

            // Generate ALL icons - let the .NET trimmer remove unused ones
            context.RegisterSourceOutput(allIcons, (spc, icons) =>
            {
                foreach (var icon in icons)
                {
                    var source = GenerateIconComponent(icon);
                    // Use fully qualified name for file to avoid conflicts
                    var fileName = $"{icon.Namespace}.{icon.Name}";
                    spc.AddSource($"{fileName}.g.cs", SourceText.From(source, Encoding.UTF8));
                }

                // Add generation info
                spc.AddSource("_IconGenerationInfo.g.cs", SourceText.From($@"// <auto-generated/>
// Total icons generated: {icons.Length}
// The .NET trimmer will remove unused icon components from published output.
namespace EasyAppDev.Blazor.Icons
{{
    internal static class IconGenerationInfo
    {{
        public const int TotalIconsGenerated = {icons.Length};
    }}
}}", Encoding.UTF8));
            });
        }

        private static List<IconInfo>? ParseIconFile(AdditionalText file, System.Threading.CancellationToken ct)
        {
            var icons = new List<IconInfo>();
            var content = file.GetText(ct)?.ToString();

            if (string.IsNullOrEmpty(content))
                return null;

            // Determine library from file path
            string? ns = null;
            string? library = null;

            if (file.Path.Contains("LucideIcons"))
            {
                ns = "EasyAppDev.Blazor.Icons.Lucide";
                library = "Lucide";
            }
            else if (file.Path.Contains("BootstrapIcons"))
            {
                ns = "EasyAppDev.Blazor.Icons.Bootstrap";
                library = "Bootstrap";
            }
            else if (file.Path.Contains("MaterialDesignIcons"))
            {
                ns = "EasyAppDev.Blazor.Icons.MaterialDesign";
                library = "MaterialDesign";
            }
            else
            {
                return null;
            }

            // Parse the C# file to extract const string declarations
            var tree = CSharpSyntaxTree.ParseText(content!, cancellationToken: ct);
            var root = tree.GetRoot(ct);

            var constFields = root.DescendantNodes()
                .OfType<FieldDeclarationSyntax>()
                .Where(f => f.Modifiers.Any(m => m.IsKind(SyntaxKind.ConstKeyword)))
                .Where(f => f.Declaration.Type.ToString() == "string");

            foreach (var field in constFields)
            {
                foreach (var variable in field.Declaration.Variables)
                {
                    var name = variable.Identifier.Text;
                    var literalValue = variable.Initializer?.Value as LiteralExpressionSyntax;
                    var svgContent = literalValue?.Token.ValueText;

                    if (!string.IsNullOrEmpty(name) && !string.IsNullOrEmpty(svgContent))
                    {
                        icons.Add(new IconInfo
                        {
                            Name = name,
                            SvgContent = svgContent!,
                            Namespace = ns,
                            Library = library
                        });
                    }
                }
            }

            return icons.Count > 0 ? icons : null;
        }

        private static string GenerateIconComponent(IconInfo icon)
        {
            var defaultAttributes = GetDefaultAttributes(icon.Library);
            var componentName = icon.Name; // Use icon name directly (Activity, not LucideActivity)

            return $@"// <auto-generated/>
#nullable enable

using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;

namespace {icon.Namespace}
{{
    /// <summary>
    /// {icon.Name} icon from {icon.Library} library.
    /// This component is fully embedded and trimmable.
    /// </summary>
    public sealed class {componentName} : ComponentBase
    {{
        /// <summary>
        /// Accessible label for the icon. If not provided, icon will be marked as decorative (aria-hidden=""true"").
        /// </summary>
        [Parameter]
        public string? AriaLabel {{ get; set; }}

        /// <summary>
        /// Additional HTML attributes to apply to the SVG element.
        /// </summary>
        [Parameter(CaptureUnmatchedValues = true)]
        public System.Collections.Generic.IReadOnlyDictionary<string, object>? AdditionalAttributes {{ get; set; }}

        /// <inheritdoc/>
        protected override void BuildRenderTree(RenderTreeBuilder builder)
        {{
            builder.OpenElement(0, ""svg"");
            builder.AddAttribute(1, ""xmlns"", ""http://www.w3.org/2000/svg"");
            builder.AddAttribute(2, ""viewBox"", ""{defaultAttributes.ViewBox}"");
            builder.AddAttribute(3, ""width"", ""24"");
            builder.AddAttribute(4, ""height"", ""24"");

            {(string.IsNullOrEmpty(defaultAttributes.Fill) ? "" : $@"builder.AddAttribute(5, ""fill"", ""{defaultAttributes.Fill}"");")}
            {(string.IsNullOrEmpty(defaultAttributes.Stroke) ? "" : $@"builder.AddAttribute(6, ""stroke"", ""{defaultAttributes.Stroke}"");")}
            {(string.IsNullOrEmpty(defaultAttributes.StrokeWidth) ? "" : $@"builder.AddAttribute(7, ""stroke-width"", ""{defaultAttributes.StrokeWidth}"");")}
            {(string.IsNullOrEmpty(defaultAttributes.StrokeLinecap) ? "" : $@"builder.AddAttribute(8, ""stroke-linecap"", ""{defaultAttributes.StrokeLinecap}"");")}
            {(string.IsNullOrEmpty(defaultAttributes.StrokeLinejoin) ? "" : $@"builder.AddAttribute(9, ""stroke-linejoin"", ""{defaultAttributes.StrokeLinejoin}"");")}

            // Add user attributes AFTER defaults so they can override
            if (AdditionalAttributes != null)
            {{
                builder.AddMultipleAttributes(10, AdditionalAttributes);
            }}

            // Accessibility attributes
            if (!string.IsNullOrEmpty(AriaLabel))
            {{
                builder.AddAttribute(11, ""role"", ""img"");
                builder.AddAttribute(12, ""aria-label"", AriaLabel);
            }}
            else
            {{
                builder.AddAttribute(11, ""aria-hidden"", ""true"");
            }}

            // Inline SVG content
            builder.AddMarkupContent(13, @""{EscapeForCSharp(icon.SvgContent)}"");
            builder.CloseElement();
        }}
    }}
}}
";
        }

        private static string EscapeForCSharp(string content)
        {
            return content.Replace("\"", "\"\"");
        }

        private static DefaultAttributes GetDefaultAttributes(string library)
        {
            return library switch
            {
                "Lucide" => new DefaultAttributes
                {
                    ViewBox = "0 0 24 24",
                    Fill = "none",
                    Stroke = "currentColor",
                    StrokeWidth = "2",
                    StrokeLinecap = "round",
                    StrokeLinejoin = "round"
                },
                "Bootstrap" => new DefaultAttributes
                {
                    ViewBox = "0 0 16 16",
                    Fill = "currentColor"
                },
                "MaterialDesign" => new DefaultAttributes
                {
                    ViewBox = "0 0 24 24",
                    Fill = "currentColor"
                },
                _ => new DefaultAttributes { ViewBox = "0 0 24 24" }
            };
        }

        private class IconInfo
        {
            public string Name { get; set; } = "";
            public string SvgContent { get; set; } = "";
            public string Namespace { get; set; } = "";
            public string Library { get; set; } = "";
        }

        private class DefaultAttributes
        {
            public string ViewBox { get; set; } = "";
            public string? Fill { get; set; }
            public string? Stroke { get; set; }
            public string? StrokeWidth { get; set; }
            public string? StrokeLinecap { get; set; }
            public string? StrokeLinejoin { get; set; }
        }
    }
}
